// Code generated by goagen v1.4.3, DO NOT EDIT.
//
// API "vulcan-core": Application User Types
//
// Command:
// $ main

package client

import (
	"github.com/goadesign/goa"
	uuid "github.com/goadesign/goa/uuid"
	"time"
	"unicode/utf8"
)

// assettypeType user type.
type assettypeType struct {
	Assettype *string  `form:"assettype,omitempty" json:"assettype,omitempty" yaml:"assettype,omitempty" xml:"assettype,omitempty"`
	Name      []string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
}

// Publicize creates AssettypeType from assettypeType
func (ut *assettypeType) Publicize() *AssettypeType {
	var pub AssettypeType
	if ut.Assettype != nil {
		pub.Assettype = ut.Assettype
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	return &pub
}

// AssettypeType user type.
type AssettypeType struct {
	Assettype *string  `form:"assettype,omitempty" json:"assettype,omitempty" yaml:"assettype,omitempty" xml:"assettype,omitempty"`
	Name      []string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
}

// checktypeType user type.
type checktypeType struct {
	// List of the asset types that this checktype allows to be used against to
	Assets      []string   `form:"assets,omitempty" json:"assets,omitempty" yaml:"assets,omitempty" xml:"assets,omitempty"`
	Description *string    `form:"description,omitempty" json:"description,omitempty" yaml:"description,omitempty" xml:"description,omitempty"`
	Enabled     *bool      `form:"enabled,omitempty" json:"enabled,omitempty" yaml:"enabled,omitempty" xml:"enabled,omitempty"`
	ID          *uuid.UUID `form:"id,omitempty" json:"id,omitempty" yaml:"id,omitempty" xml:"id,omitempty"`
	// Image that needs to be pulled to run the Check of this type
	Image *string `form:"image,omitempty" json:"image,omitempty" yaml:"image,omitempty" xml:"image,omitempty"`
	Name  *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	// Default configuration options for the Checktype. It should be in JSON format
	Options *string `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
	// The queue name to be used by a check of this type
	QueueName *string `form:"queue_name,omitempty" json:"queue_name,omitempty" yaml:"queue_name,omitempty" xml:"queue_name,omitempty"`
	// List of required vars that the agent must inject to a check using this checktype
	RequiredVars []string `form:"required_vars,omitempty" json:"required_vars,omitempty" yaml:"required_vars,omitempty" xml:"required_vars,omitempty"`
	// Specifies the maximum amount of time that the check should be running before it's killed
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty" yaml:"timeout,omitempty" xml:"timeout,omitempty"`
}

// Validate validates the checktypeType type instance.
func (ut *checktypeType) Validate() (err error) {
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	if ut.Name == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "name"))
	}
	if ut.Image == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "image"))
	}
	if ut.Description != nil {
		if ok := goa.ValidatePattern(`^[[:print:]]+`, *ut.Description); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.description`, *ut.Description, `^[[:print:]]+`))
		}
	}
	if ut.Description != nil {
		if utf8.RuneCountInString(*ut.Description) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.description`, *ut.Description, utf8.RuneCountInString(*ut.Description), 255, false))
		}
	}
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[[:word:]]+`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[[:word:]]+`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	return
}

// Publicize creates ChecktypeType from checktypeType
func (ut *checktypeType) Publicize() *ChecktypeType {
	var pub ChecktypeType
	if ut.Assets != nil {
		pub.Assets = ut.Assets
	}
	if ut.Description != nil {
		pub.Description = ut.Description
	}
	if ut.Enabled != nil {
		pub.Enabled = ut.Enabled
	}
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Image != nil {
		pub.Image = *ut.Image
	}
	if ut.Name != nil {
		pub.Name = *ut.Name
	}
	if ut.Options != nil {
		pub.Options = ut.Options
	}
	if ut.QueueName != nil {
		pub.QueueName = ut.QueueName
	}
	if ut.RequiredVars != nil {
		pub.RequiredVars = ut.RequiredVars
	}
	if ut.Timeout != nil {
		pub.Timeout = ut.Timeout
	}
	return &pub
}

// ChecktypeType user type.
type ChecktypeType struct {
	// List of the asset types that this checktype allows to be used against to
	Assets      []string  `form:"assets,omitempty" json:"assets,omitempty" yaml:"assets,omitempty" xml:"assets,omitempty"`
	Description *string   `form:"description,omitempty" json:"description,omitempty" yaml:"description,omitempty" xml:"description,omitempty"`
	Enabled     *bool     `form:"enabled,omitempty" json:"enabled,omitempty" yaml:"enabled,omitempty" xml:"enabled,omitempty"`
	ID          uuid.UUID `form:"id" json:"id" yaml:"id" xml:"id"`
	// Image that needs to be pulled to run the Check of this type
	Image string `form:"image" json:"image" yaml:"image" xml:"image"`
	Name  string `form:"name" json:"name" yaml:"name" xml:"name"`
	// Default configuration options for the Checktype. It should be in JSON format
	Options *string `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
	// The queue name to be used by a check of this type
	QueueName *string `form:"queue_name,omitempty" json:"queue_name,omitempty" yaml:"queue_name,omitempty" xml:"queue_name,omitempty"`
	// List of required vars that the agent must inject to a check using this checktype
	RequiredVars []string `form:"required_vars,omitempty" json:"required_vars,omitempty" yaml:"required_vars,omitempty" xml:"required_vars,omitempty"`
	// Specifies the maximum amount of time that the check should be running before it's killed
	Timeout *int `form:"timeout,omitempty" json:"timeout,omitempty" yaml:"timeout,omitempty" xml:"timeout,omitempty"`
}

// Validate validates the ChecktypeType type instance.
func (ut *ChecktypeType) Validate() (err error) {

	if ut.Name == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "name"))
	}
	if ut.Image == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "image"))
	}
	if ut.Description != nil {
		if ok := goa.ValidatePattern(`^[[:print:]]+`, *ut.Description); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.description`, *ut.Description, `^[[:print:]]+`))
		}
	}
	if ut.Description != nil {
		if utf8.RuneCountInString(*ut.Description) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.description`, *ut.Description, utf8.RuneCountInString(*ut.Description), 255, false))
		}
	}
	if ok := goa.ValidatePattern(`^[[:word:]]+`, ut.Name); !ok {
		err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, ut.Name, `^[[:word:]]+`))
	}
	if utf8.RuneCountInString(ut.Name) < 1 {
		err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, ut.Name, utf8.RuneCountInString(ut.Name), 1, true))
	}
	return
}

// checktypesGroup user type.
type checktypesGroup struct {
	Checktypes []*scanChecktype `form:"checktypes,omitempty" json:"checktypes,omitempty" yaml:"checktypes,omitempty" xml:"checktypes,omitempty"`
	Name       *string          `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
}

// Publicize creates ChecktypesGroup from checktypesGroup
func (ut *checktypesGroup) Publicize() *ChecktypesGroup {
	var pub ChecktypesGroup
	if ut.Checktypes != nil {
		pub.Checktypes = make([]*ScanChecktype, len(ut.Checktypes))
		for i2, elem2 := range ut.Checktypes {
			pub.Checktypes[i2] = elem2.Publicize()
		}
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	return &pub
}

// ChecktypesGroup user type.
type ChecktypesGroup struct {
	Checktypes []*ScanChecktype `form:"checktypes,omitempty" json:"checktypes,omitempty" yaml:"checktypes,omitempty" xml:"checktypes,omitempty"`
	Name       *string          `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
}

// scanChecktype user type.
type scanChecktype struct {
	Name    *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	Options *string `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
}

// Publicize creates ScanChecktype from scanChecktype
func (ut *scanChecktype) Publicize() *ScanChecktype {
	var pub ScanChecktype
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Options != nil {
		pub.Options = ut.Options
	}
	return &pub
}

// ScanChecktype user type.
type ScanChecktype struct {
	Name    *string `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	Options *string `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
}

// scanPayload user type.
type scanPayload struct {
	ExternalID    *uuid.UUID          `form:"external_id,omitempty" json:"external_id,omitempty" yaml:"external_id,omitempty" xml:"external_id,omitempty"`
	ScheduledTime *time.Time          `form:"scheduled_time,omitempty" json:"scheduled_time,omitempty" yaml:"scheduled_time,omitempty" xml:"scheduled_time,omitempty"`
	Tag           *string             `form:"tag,omitempty" json:"tag,omitempty" yaml:"tag,omitempty" xml:"tag,omitempty"`
	TargetGroups  []*scanTargetsGroup `form:"target_groups,omitempty" json:"target_groups,omitempty" yaml:"target_groups,omitempty" xml:"target_groups,omitempty"`
	Trigger       *string             `form:"trigger,omitempty" json:"trigger,omitempty" yaml:"trigger,omitempty" xml:"trigger,omitempty"`
}

// Publicize creates ScanPayload from scanPayload
func (ut *scanPayload) Publicize() *ScanPayload {
	var pub ScanPayload
	if ut.ExternalID != nil {
		pub.ExternalID = ut.ExternalID
	}
	if ut.ScheduledTime != nil {
		pub.ScheduledTime = ut.ScheduledTime
	}
	if ut.Tag != nil {
		pub.Tag = ut.Tag
	}
	if ut.TargetGroups != nil {
		pub.TargetGroups = make([]*ScanTargetsGroup, len(ut.TargetGroups))
		for i2, elem2 := range ut.TargetGroups {
			pub.TargetGroups[i2] = elem2.Publicize()
		}
	}
	if ut.Trigger != nil {
		pub.Trigger = ut.Trigger
	}
	return &pub
}

// ScanPayload user type.
type ScanPayload struct {
	ExternalID    *uuid.UUID          `form:"external_id,omitempty" json:"external_id,omitempty" yaml:"external_id,omitempty" xml:"external_id,omitempty"`
	ScheduledTime *time.Time          `form:"scheduled_time,omitempty" json:"scheduled_time,omitempty" yaml:"scheduled_time,omitempty" xml:"scheduled_time,omitempty"`
	Tag           *string             `form:"tag,omitempty" json:"tag,omitempty" yaml:"tag,omitempty" xml:"tag,omitempty"`
	TargetGroups  []*ScanTargetsGroup `form:"target_groups,omitempty" json:"target_groups,omitempty" yaml:"target_groups,omitempty" xml:"target_groups,omitempty"`
	Trigger       *string             `form:"trigger,omitempty" json:"trigger,omitempty" yaml:"trigger,omitempty" xml:"trigger,omitempty"`
}

// scanTargetsGroup user type.
type scanTargetsGroup struct {
	ChecktypesGroup *checktypesGroup `form:"checktypes_group,omitempty" json:"checktypes_group,omitempty" yaml:"checktypes_group,omitempty" xml:"checktypes_group,omitempty"`
	TargetGroup     *targetGroup     `form:"target_group,omitempty" json:"target_group,omitempty" yaml:"target_group,omitempty" xml:"target_group,omitempty"`
}

// Publicize creates ScanTargetsGroup from scanTargetsGroup
func (ut *scanTargetsGroup) Publicize() *ScanTargetsGroup {
	var pub ScanTargetsGroup
	if ut.ChecktypesGroup != nil {
		pub.ChecktypesGroup = ut.ChecktypesGroup.Publicize()
	}
	if ut.TargetGroup != nil {
		pub.TargetGroup = ut.TargetGroup.Publicize()
	}
	return &pub
}

// ScanTargetsGroup user type.
type ScanTargetsGroup struct {
	ChecktypesGroup *ChecktypesGroup `form:"checktypes_group,omitempty" json:"checktypes_group,omitempty" yaml:"checktypes_group,omitempty" xml:"checktypes_group,omitempty"`
	TargetGroup     *TargetGroup     `form:"target_group,omitempty" json:"target_group,omitempty" yaml:"target_group,omitempty" xml:"target_group,omitempty"`
}

// target user type.
type target struct {
	Identifier *string `form:"identifier,omitempty" json:"identifier,omitempty" yaml:"identifier,omitempty" xml:"identifier,omitempty"`
	Options    *string `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
	Type       *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates Target from target
func (ut *target) Publicize() *Target {
	var pub Target
	if ut.Identifier != nil {
		pub.Identifier = ut.Identifier
	}
	if ut.Options != nil {
		pub.Options = ut.Options
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// Target user type.
type Target struct {
	Identifier *string `form:"identifier,omitempty" json:"identifier,omitempty" yaml:"identifier,omitempty" xml:"identifier,omitempty"`
	Options    *string `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
	Type       *string `form:"type,omitempty" json:"type,omitempty" yaml:"type,omitempty" xml:"type,omitempty"`
}

// targetGroup user type.
type targetGroup struct {
	Name    *string   `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	Options *string   `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
	Targets []*target `form:"targets,omitempty" json:"targets,omitempty" yaml:"targets,omitempty" xml:"targets,omitempty"`
}

// Publicize creates TargetGroup from targetGroup
func (ut *targetGroup) Publicize() *TargetGroup {
	var pub TargetGroup
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.Options != nil {
		pub.Options = ut.Options
	}
	if ut.Targets != nil {
		pub.Targets = make([]*Target, len(ut.Targets))
		for i2, elem2 := range ut.Targets {
			pub.Targets[i2] = elem2.Publicize()
		}
	}
	return &pub
}

// TargetGroup user type.
type TargetGroup struct {
	Name    *string   `form:"name,omitempty" json:"name,omitempty" yaml:"name,omitempty" xml:"name,omitempty"`
	Options *string   `form:"options,omitempty" json:"options,omitempty" yaml:"options,omitempty" xml:"options,omitempty"`
	Targets []*Target `form:"targets,omitempty" json:"targets,omitempty" yaml:"targets,omitempty" xml:"targets,omitempty"`
}
